8월 31일 월요일

# 웹 브라우저는 어떻게 동작하는가?



원문 링크 : https://medium.com/@monica1109/how-does-web-browsers-work-c95ad628a509







## 브라우저란 뭘까?

* 브라우저는 World Wide Web 위에서 웹 페이지, 이미지, 비디오, 기타 파일과 같은 컨텐츠들을 추적하고, 검색하고, 표시하는 어플리케이션이다.
* 클라이언트/서버 모델에서, 브라우저는 컴퓨터 위에서 돌아가며 웹 서버와 통신하며 정보를 요청하는 클라이언트로서의 역할을 한다.
* 웹 서버는 웹 브라우저에 정보를 되돌려주고, 컴퓨터나 브라우저를 지원하는 기기는 이 정보를 화면에 띄워준다.



## 오늘날의 브라우저

* 오늘날의 브라우저들은 웹 서버가 호스팅하는 HTML 웹 페이지, 어플리케이션, 자바스크립트, AJAX 등의 컨텐츠를 해석하고 렌더링하는 fully-functional한 소프트웨어이다.
* 많은 브라우저들이 소리, 비디오, 화상회의, 웹 디자인, 보안 등의 작업을 수행할 수 있게 하는 플러그인들을 제공하고 있다.



## 브라우저의 구조

* 브라우저는 화면에 웹 페이지를 띄우기 위한 코드들이 모여 구조화된 결과물이라고 할 수 있다.
* 수행하는 일에 따라, 이 코드들은 각기 다른 컴포넌트들로 구성되어 있다.

* 웹 브라우저의 컴포넌트 구조를 다음 그림을 통해 살펴보자.
![img](https://miro.medium.com/max/624/1*RL0pnuf_hmLJ76oY6DViZw.png)

> 브라우저의 메인 컴포넌트들



1. 유저 인터페이스 (User Interface) :

   * 사용자가 브라우저와 상호작용하는 공간을 말한다.
   * 주소창, 뒤로/앞으로가기 버튼, 홈버튼, 새로고침/중지 버튼, 북마크 옵션 등이 있다.
   * 요청한 웹 페이지를 제외한 나머지 UI

   

2. 브라우저 엔진 (Browser Engine) :

   * 유저 인터페이스와 렌더링 엔진 간의 다리 역할을 한다.
   * 유저 인터페이스로부터 전해진 다양한 인풋에 따라, 브라우저 엔진이 렌더링 엔진에 여러 요청을 보낸다.

   

3. 렌더링 엔진 (Rendering Engine) : 

   * 요청한 웹 페이지를 브라우저 화면에 렌더링하는 역할을 한다.

   * 렌더링 엔진은 HTML, XML 문서, CSS로 포맷된 이미지를 해석하고 레이아웃을 생성한다.

   * 그러나, 플러그인이나 확장 프로그램을 사용하면 다른 타입의 데이터도 보여줄 수 있다.

   * 브라우저마다 각기 다른 렌더링 엔진을 사용하고 있다.

     * Internet Explorer : Trident
     * Firefox & other Mozila browsers : Gecko
     * Chrome & Opera 15+ : Blink
     * Chrome (iPhone) & Safari : Webkit

     

4. 네트워킹 (Networking) :

   * 일반적인 인터넷 프로토콜인 HTTP나 FTP 를 사용하여  URL을 검색하는 컴포넌트이다.
   * 네트워킹 컴포넌트는 인터넷 통신과 보안에 대한 모든 측면을 다룬다.
   * 네트워크 컴포넌트는 검색된 문서를 캐싱하여 네트워크 트래픽을 줄이기도 한다.

   

5. 자바스크립트 해석기 (JavaScript Interpreter) :

   * 웹사이트 내부에 박힌 자바스크립트를 해석하고 실행시켜주는 컴포넌트이다.
   * JS 해석 결과는 렌더링 엔진에 보내져 화면 렌더링에 쓰인다.
   * 만약 스크립트가 외부의 것이라면, 첫 리소스는 네트워크에서 받아져 온다. 
   * 스크립트가 실행되기 전까지 파서는 보류된다.

   

6. UI 백엔드 (UI Backend) :

   * 콤보박스나 창과 같은 기본 위젯들을 그리는 데 쓰인다.
   * 이 백엔드는 특정 플랫폼이 아닌 일반 인터페이스를 표시한다.
   * 내부에서는 운영 체제 사용자 인터페이스 메소드를 사용한다.

   

7. 데이터 영속성/저장소 (Data Persistence/Storage) :

   * 영속 레이어이다.
   * 브라우저는 로컬스토리지, IndexedDb, WebSQL, FileSystem과 같은 저장 메카니즘들을 지원한다.
   * 브라우저가 설치될 때 사용자의 로컬 드라이브에 생성되는 작은 데이터베이스라고 보면 된다.
   * 캐시, 쿠키, 북마크 등의 유저 정보를 저장하고 있다.

> Google Chrome 과 같은 웹 브라우저는 각 탭마다 다른 프로세스를 실행시킨다. 즉 렌더링 엔진의 인스턴스가 탭의 개수만큼 생성된다는 말이다.





## 렌더링 엔진 (Rendering Engine)

* 네트워킹 레이어는 요청된 문서의 콘텐츠를 8kb의 덩어리로 나눠 렌더링 엔진으로 보낸다.
* ![img](https://miro.medium.com/max/750/1*cfQpu6Xvb7e9IiH4CCuiCg.png)

> 렌더링 엔진의 기본 흐름

### 렌더링 엔진 흐름 분석

1. 돔 트리 구성(DOM tree) :

   * 렌더링 엔진은 수신한 HTML 문서의 요소들을 돔 노드들로 변환시켜 돔 트리를 구성한다.



2. CSSOM 트리 구성 (CSSOM tree) :

  *  렌더 트리를 형성하는 것은 돔 트리 + CSSOM 트리이다.
  *  돔 트리가 콘텐츠 그 자체를 구성한다면, CSSOM 트리는 각 콘텐츠에 대한 스타일 규칙을 구성한다.

   

3. 렌더 트리 형성 (Render tree construction) :

   * 돔 트리 + CSSOM 트리가 형성되는 동안, 브라우저는 또 다른 트리를 만드는데, 이를 렌더 트리 라고 한다.
   * 이 트리는 문서를 채울 시각적 요소들로 이루어져 있다.
   * 이 트리의 목적은 각 컨텐츠를 올바른 순서로 화면에 그리는 것이다.

   

4. 렌더 트리에 의한 레이아웃 (Layout of the render tree) :

   * 렌더 트리 형성이 끝난 뒤, 렌더 트리의 레이아웃 과정을 거친다.
   * 어떤 요소가 생성되고 트리에 추가될 때, 레이아웃 이전의 해당 요소는 아직 위치와 크기를 갖지 않는다. 위치와 크기값은 레이아웃(혹은 reflow) 과정에서 정해진다.
   * root renderer의 위치는 0,0 이며, 브라우저의 viewport 차원에 위치한다.
   * 모든 renderer는 layout 메소드를 갖고 있으며, 각각의 renderer는 자식 renderer 의 레이아웃이 필요할 때 자식 renderer의  layout 메소드를 호출한다.

   

5. 렌더 트리 페인팅 (Painting the render tree) :

   * 다음 단계는 페인팅이다. 페인팅 단계에서, 렌더 트리는 쭉 훑어진다.
   * 그리고 renderer의 paint() 메소드가 호출되어 콘텐츠를 화면에 그린다.
   * 페인팅은 UI 백엔드 레이어를 사용한다.

   

   ## 렌더링 엔진과 HTML 파싱은 병렬

   * 렌더링 엔진은 더 나은 유저 경험을 위해 가능한 한 빨리 컨텐츠를 스크린에 그리려 노력한다.
   * 이를 위해, 렌더링 엔진은 HTML 파싱이 끝나기를 기다리지 않고 렌더 트리를 생성하고 레이아웃을 짠다. (async)
     * 반대로, HTML 파싱이 끝나기를 기다린 뒤 렌더 트리를 생성하는 방법도 있는데, 이를 defer 방식이라고 함.
   * 네트워크로 컨텐츠를 받는 도중에 컨텐츠를 파싱하고 화면에 표시하는 작업을 계속 해나간다.

